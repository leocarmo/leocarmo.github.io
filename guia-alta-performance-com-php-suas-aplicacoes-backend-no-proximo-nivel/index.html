<!doctype html><html lang=en>
<head>
<title>Guia: Alta performance com PHP — Suas aplicações backend no próximo nível :: leocarmo.dev</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="O PHP é muito poderoso, só depende de nós utilizá-lo da melhor forma. Meu objetivo com esta publicação é ajudar nesta jornada.">
<meta name=keywords content>
<meta name=robots content="noodp">
<link rel=canonical href=/guia-alta-performance-com-php-suas-aplicacoes-backend-no-proximo-nivel/>
<link rel=stylesheet href=/assets/style.css>
<link rel=stylesheet href=/assets/green.css>
<link rel=stylesheet href=/style.css>
<link rel=apple-touch-icon href=/img/apple-touch-icon-192x192.png>
<link rel="shortcut icon" href=/img/favicon/green.png>
<meta name=twitter:card content="summary">
<meta property="og:locale" content="en">
<meta property="og:type" content="article">
<meta property="og:title" content="Guia: Alta performance com PHP — Suas aplicações backend no próximo nível">
<meta property="og:description" content="O PHP é muito poderoso, só depende de nós utilizá-lo da melhor forma. Meu objetivo com esta publicação é ajudar nesta jornada.">
<meta property="og:url" content="/guia-alta-performance-com-php-suas-aplicacoes-backend-no-proximo-nivel/">
<meta property="og:site_name" content="leocarmo.dev">
<meta property="og:image" content="/guia-alta-performance-com-php-suas-aplica%C3%A7%C3%B5es-backend-no-pr%C3%B3ximo-n%C3%ADvel/images/foguete.jpeg">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">
<meta property="article:published_time" content="2020-05-12 19:30:00 -0300 -0300">
</head>
<body class=green>
<div class="container center headings--one-size">
<header class=header>
<div class=header__inner>
<div class=header__logo>
<a href=/>
<div class=logo>
leocarmo.dev
</div>
</a>
</div>
<div class=menu-trigger>menu</div>
</div>
<nav class=menu>
<ul class="menu__inner menu__inner--desktop">
<li><a href=https://github.com/leocarmo>github</a></li>
<li><a href=https://www.linkedin.com/in/leonardocarmo/>linkedin</a></li>
<li><a href=/index.xml>rss</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href=https://github.com/leocarmo>github</a></li>
<li><a href=https://www.linkedin.com/in/leonardocarmo/>linkedin</a></li>
<li><a href=/index.xml>rss</a></li>
</ul>
</nav>
</header>
<div class=content>
<div class=post>
<h1 class=post-title>
<a href=/guia-alta-performance-com-php-suas-aplicacoes-backend-no-proximo-nivel/>Guia: Alta performance com PHP — Suas aplicações backend no próximo nível</a></h1>
<div class=post-meta>
<span class=post-date>
2020-05-12
</span>
<span class=post-author>:: leocarmo</span>
</div>
<span class=post-tags>
#<a href=/tags/php/>php</a>&nbsp;
#<a href=/tags/swoole/>swoole</a>&nbsp;
#<a href=/tags/php-fpm/>php-fpm</a>&nbsp;
#<a href=/tags/opcache/>opcache</a>&nbsp;
</span>
<img src=/guia-alta-performance-com-php-suas-aplica%C3%A7%C3%B5es-backend-no-pr%C3%B3ximo-n%C3%ADvel/images/foguete.jpeg class=post-cover alt="Guia: Alta performance com PHP — Suas aplicações backend no próximo nível">
<div class=post-content><div>
<p>Muitas pessoas dizem que alta performance e PHP não existem na mesma frase. Se você ainda pensa assim, vou te provar o contrário.</p>
<p>O PHP é muito poderoso, só depende de nós utilizá-lo da melhor forma. Meu objetivo com esta publicação é ajudar nesta jornada.</p>
<p>Todo mundo já sabe que grandes empresas usam PHP, mas esse não é o argumento mais forte ao se falar sobre este assunto.</p>
<p>Argumentos fortes são: aplicações poderosas, resoluções de problemas de forma inteligente e implementações diferentes do comum. E vamos falar muito sobre isso aqui!</p>
<p>Não vou abordar apenas tópicos voltados ao código, a ideia é falar sobre o ambiente como um todo: arquitetura, implementações e, claro, código.</p>
<p>Um ponto importante é que vamos focar exclusivamente em aplicações backend, funcionando sem renderização de views. Pois, caso sua aplicação seja full stack, muitas outras otimizações ainda precisam ser feitas.</p>
<p>Começaremos do básico e vamos aprofundando em assuntos mais complexos aos poucos. Alguns tópicos irei apenas trazer ideias iniciais, e depois te direcionar para outras publicações onde você possa estudar e entender mais sobre eles.</p>
<p>Quero te guiar pelas melhores práticas para conseguir, de fato, elevar o nível das suas aplicações de forma fácil e objetiva. Então bora lá!</p>
<h4 id=tópicos>Tópicos<a href=#tópicos class=hanchor arialabel=Anchor>&#8983;</a> </h4>
<ol>
<li><a href=#1-atualize-tudo-sempre>Atualize TUDO, sempre!</a></li>
<li><a href=#2-refatore-sua-infraestrutura>Refatore sua infraestrutura</a></li>
<li><a href=#3-boas-pr%C3%A1ticas-e-padr%C3%B5es-de-projeto>Boas práticas e padrões de projeto</a></li>
<li><a href=#4-frameworks>Frameworks</a></li>
<li><a href=#5-otimizando-o-php-fpm>Otimizando o PHP-FPM</a></li>
<li><a href=#6-o-poder-do-opcache>O poder do OPcache</a></li>
<li><a href=#7-utilize-cache-em-mem%C3%B3ria>Utilize cache em memória</a></li>
<li><a href=#8-conex%C3%B5es-persistentes>Conexões persistentes</a></li>
<li><a href=#9-fun%C3%A7%C3%B5es-nativas>Funções nativas</a></li>
<li><a href=#10-preloading>Preloading</a></li>
<li><a href=#11-generators>Generators</a></li>
<li><a href=#12-c%C3%B3digo-ass%C3%ADncrono>Código assíncrono</a></li>
<li><a href=#13-non-blocking-io-com-php>Non-blocking I/O com PHP</a></li>
</ol>
<hr>
<h2 id=1-atualize-tudo-sempre>1. Atualize TUDO, sempre!<a href=#1-atualize-tudo-sempre class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>É, parece bem óbvio. Mas quando foi a última vez que você atualizou as dependências do seu projeto? E a versão do PHP?</p>
<p>De acordo com a <a href=https://w3techs.com/technologies/details/pl-php>W3Techs</a>, o PHP é utilizado por 78.2% de todos os websites, considerando sua linguagem de backend.</p>
<blockquote>
<p>WOOW THAT’S AWESOME!</p>
</blockquote>
<p>Nem tanto… Essa é uma das razões de muita gente não gostar de PHP e falar coisas bem ruins (digamos que, nesse caso, não estão errados).</p>
<p>A versão 7 é utilizada por apenas 50.8% desses websites. Ou seja, a outra metade está utilizando uma versão terrível…</p>
<p><img src=images/1.png alt=1.1.png></p>
<p>E ainda fica pior, mesmo na versão 7, menos de 30% estão utilizando uma versão com suporte ativo, analisando o dia que estou escrevendo. E apenas 3.6% estão na ultima versão estável disponível (7.4), o que é péssimo!</p>
<p><img src=images/2.png alt=1.2.png></p>
<p>Mas o que isso tem a ver com performance? TUDO! Alem de ficar cada vez mais performático, muitas atualizações de segurança são lançadas, o que já seria suficiente para você atualizar seu PHP.</p>
<blockquote>
<p>Lembre-se: alem do PHP, é preciso atualizar suas dependências do composer e suas extensões!</p>
</blockquote>
<p>Para ver um pouco mais sobre testes de performance, acesse <a href=https://kinsta.com/blog/php-benchmarks/>este link</a>.</p>
<p><img src=images/3.png alt=1.3.png></p>
<p>E o <a href=https://stitcher.io/blog/new-in-php-8>8.0 vem aí</a> com novidades e, claro, mais <a href=https://thephp.website/br/edicao/php-8-jit/>melhorias em performance</a>. Aqui falamos apenas do PHP, mas temos extensões e bibliotecas também, então: atualize TUDO, sempre!</p>
<hr>
<h2 id=2-refatore-sua-infraestrutura>2. Refatore sua infraestrutura<a href=#2-refatore-sua-infraestrutura class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>Mais uma coisa óbvia? Talvez. Mas sabemos que muitos sistemas rodam tudo no mesmo servidor: banco de dados, aplicação, webserver, cache, sistema de arquivos…</p>
<p>Algumas pessoas justificam isso dizendo que é para redução de custos. De início tudo bem, mas se seu sistema começar a crescer, essa conta não vai ficar barata. Dividir processamento entre diversos processos vai degradar a performance como um todo, mesmo com muito recurso disponível.</p>
<p>Dividir os serviços que você utiliza, permite um gerenciamento por demanda dos recursos. Ou seja, caso seu banco precise de mais memória, apenas ele sofre um upgrade pontual, sem precisar ter uma máquina gigante com tudo dentro.</p>
<p>Essa refatoração com certeza vai melhorar a performance do seu sistema como um todo e, dependendo do nível de tráfego, também vai reduzir seus custos e complexidade de gerenciamento.</p>
<p>Alguns serviços e dicas que podem ajudar:</p>
<ul>
<li>Nginx no lugar do Apache (<a href=https://serverguy.com/comparison/apache-vs-nginx/>Por quê?</a> / <a href=https://www.nginx.com/blog/tuning-nginx/>Como?</a>)</li>
<li>Utilize <a href=https://dzone.com/articles/top-10-benefits-of-using-docker>Docker</a></li>
<li><a href=https://docs.aws.amazon.com/AmazonECS/latest/developerguide/Welcome.html>Elastic container service</a></li>
<li><a href="https://aws.amazon.com/rds/?nc1=h_ls">Relational database service</a></li>
<li><a href="https://aws.amazon.com/s3/?nc1=h_ls">Cloud object storage</a></li>
</ul>
<blockquote>
<p>Você pode usar qualquer cloud provider, os links são para que você conheça mais sobre este tipo de serviço gerenciado.</p>
</blockquote>
<p>Esse é o básico para que você comece a refatorar sua infraestrutura. Existem muitos outros serviços interessantes que também podem ajudar, vamos falar sobre alguns deles em outros tópicos.</p>
<hr>
<h2 id=3-boas-práticas-e-padrões-de-projeto>3. Boas práticas e padrões de projeto<a href=#3-boas-práticas-e-padrões-de-projeto class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>Não vou abordar cada padrão de projeto aqui, a ideia é ressaltar a importância de levar tudo isso muito a sério.</p>
<p>Por mais que sempre lemos essas palavras por aí, estamos realmente colocando isso em prática? Dentre todos os benefícios, performance com certeza está entre eles.</p>
<p>Podemos destacar a <a href=https://szymonkrajewski.pl/why-should-you-return-early/>early return pattern</a>, que influencia diretamente a performance das aplicações quando trabalhamos com altas volumetrias. Quanto mais rápido conseguirmos responder uma requisição, mais rápido estaremos prontos para a próxima!</p>
<p>Utilizar padrões de projeto e boas práticas é trazer soluções inteligentes e performáticas para suas aplicações, então, sempre que fizer sentido, utilize!</p>
<blockquote>
<p>Mas atenção, <a href=https://en.wikipedia.org/wiki/KISS_principle>KISS</a>! Padrões não são soluções para tudo, saiba utilizar de forma inteligente e não como bala de prata.</p>
</blockquote>
<p>Alguns materiais para se aprofundar no assunto:</p>
<ul>
<li><a href=https://sourcemaking.com/design_patterns>Design patterns</a></li>
<li><a href=https://scotch.io/bar-talk/s-o-l-i-d-the-first-five-principles-of-object-oriented-design>SOLID</a></li>
<li><a href=https://www.php-fig.org/psr/>PHP Standards Recommendations</a></li>
<li><a href=https://en.wikipedia.org/wiki/Don%27t_repeat_yourself>Don’t repeat yourself</a></li>
<li><a href=https://github.com/leocarmo/circuit-breaker-php>Circuit Breaker Pattern</a></li>
</ul>
<hr>
<h2 id=4-frameworks>4. Frameworks<a href=#4-frameworks class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>Este sempre acaba sendo um assunto polêmico. Então, vamos tirar um pouco o foco apenas da perfomance e pensar em outros tópicos importantes para este assunto.</p>
<p>A escolha de um framework tem que levar outros aspectos em consideração, entre eles gostaria de destacar alguns:</p>
<ul>
<li>A equipe está confortável em trabalhar com ele?</li>
<li>A comunidade é ativa?</li>
<li>Ele é atualizado com qual frequência?</li>
<li>A documentação é bem estruturada?</li>
<li>Já pensou em usar um micro-framework?</li>
</ul>
<p>Estes são pontos que podem influenciar o futuro da sua aplicação, pois, se não for atualizado com frequência, sua performance pode ser degradada. Se a comunidade não estiver ativa o suficiente, o mesmo pode acontecer.</p>
<p>Então, ao escolher, leve em consideração outros aspectos importantes.</p>
<hr>
<h2 id=5-otimizando-o-php-fpm>5. Otimizando o PHP-FPM<a href=#5-otimizando-o-php-fpm class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>Iniciando os tópicos um pouco mais avançados, vamos falar sobre o <a href=https://www.php.net/manual/en/install.fpm.php>php-fpm</a>. Aqui, vamos considerar que você já utiliza o Nginx com o php-fpm e que já <a href=https://www.inmotionhosting.com/support/website/php-fpm-the-future-of-php-handling/>saiba como ele funciona</a>, pelo menos de forma básica. Se não utiliza, a primeira recomendação é mudar para essa combinação extremamente poderosa.</p>
<p>As configurações que vamos abordar aqui, leva em consideração que seu sistema tem um grande volume de requisições.</p>
<p>Vamos focar aqui na configuração dos processos que serão abertos e gerenciados pelo fpm. Com isso, a melhor forma de gerenciar estes processos em alta volumetria é de forma estática. Assim, o fpm não vai precisar se preocupar em aumentar ou diminuir cada um deles.</p>
<p>Outro ponto importante é a quantidade de requisições que cada processo irá processar antes de ser renovado. Temos que pensar no equilíbrio, pois, enquanto um número muito alto pode causar um <a href=https://medium.com/@FreeDev/tenha-cuidado-com-o-memory-leak-b171622b4c6b>memory leak</a>, um número muito baixo pode fazer com que, a todo momento, o fpm tenha que lidar com o start de um novo processo. Então saiba quanto cada uma das suas requisições utiliza de memória para ajustar essa configuração, para isso faça <a href=https://stackify.com/php-profiling-find-slow-code/>profilling</a>!</p>
<p>Sendo assim, um exemplo de configuração seria:</p>
<pre><code>[api]
pm = static
pm.max_children = 16
pm.max_requests = 10000
</code></pre><p>Com workers estáticos já teremos uma grande diferença. Claro, existem diversas outras configurações, então para saber um pouco mais, aqui tem <a href=https://geekflare.com/php-fpm-optimization/>um artigo</a> abordando mais sobre este assunto.</p>
<hr>
<h2 id=6-o-poder-do-opcache>6. O poder do OPcache<a href=#6-o-poder-do-opcache class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>Esta é uma extensão muito poderosa para o PHP, se você não utiliza, pare tudo e implemente o quanto antes! Para uma rápida introdução, o que diz a <a href=https://www.php.net/manual/en/book.opcache.php>documentação</a>:</p>
<blockquote>
<p>OPcache improves PHP performance by storing precompiled script bytecode in shared memory, thereby removing the need for PHP to load and parse scripts on each request.</p>
</blockquote>
<p>Com isso, já da pra sentir o poder que ele pode dar para suas aplicações. Todo o sistema será compilado apenas uma vez e estará disponível em memória para as próximas requisições. Show!</p>
<p>Um benchmark para mostrar o poder do OPcache:</p>
<p><img src=images/4.png alt=opcache.png></p>
<blockquote>
<p><a href=https://www.ibexa.co/blog/benchmarking-php-7.3-vs-7.4-with-symfony-4.4-trouble-with-opcache-preloading>Fonte da imagem</a></p>
</blockquote>
<p>Começar a utilizar é muito fácil, basta instalar, configurar e pronto! Porém, como aponta a documentação, todos os scripts vão para memória. Isso significa que, caso não utilize container, ao atualizar seu projeto, é preciso dar um reload no seu processo do fpm para que ele limpe os scripts antigos e recompile os novos.</p>
<p>Vou deixar aqui uma configuração bem interessante para iniciar:</p>
<pre><code>[opcache]
opcache.enable=1
opcache.memory_consumption=128
opcache.max_accelerated_files=4000
opcache.validate_timestamps=0
opcache.interned_strings_buffer=12
opcache.use_cwd=0
</code></pre><p>Existem <a href=https://www.php.net/manual/en/opcache.configuration.php>diversas configurações disponíveis</a>, basta dar uma olhada na documentação e configurar conforme fizer sentido para sua aplicação. Para saber mais sobre o OPcache, existem muitos materiais bacanas disponíveis, <a href=https://www.cloudways.com/blog/integrate-php-opcache/>aqui tem um</a>.</p>
<hr>
<h2 id=7-utilize-cache-em-memória>7. Utilize cache em memória<a href=#7-utilize-cache-em-memória class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>&ldquo;Cachear&rdquo; sua aplicação de forma inteligente pode ser uma das coisas mais importantes para se obter um ganho expressivo em performance e redução de custos.</p>
<p>Sabe quando você precisa utilizar um mesmo código em dois lugares diferentes e, para isso, você cria um método que possui esse mesmo &ldquo;trabalho&rdquo; a ser feito? Utilizar cache é basicamente armazenar um trabalho já feito para ser reaproveitado.</p>
<p>Os ganhos? Performance claro, se aquele trabalho demorava 1s, usando cache pode chegar a demorar 5ms. Sim, é muito poderoso. E isso nos leva a redução de custos, na aplicação e no banco de dados, pois a ideia é reduzir as chamadas ao banco também.</p>
<p>Não existe uma estratégia pronta para isso, quem define é você. Mas o direcionamento do pensamento é: posso reutilizar um trabalho já feito para as próximas requisições? Um exemplo prático e simples: um blog possui uma sessão de &ldquo;mais visualizados&rdquo;, para isso, é preciso pegar todas as publicações e ordena-las pelo número de views. A cada requisição você realmente precisa fazer isso? Ou pode armazenar esse trabalho durante um tempo? Então utilize cache por 30m por exemplo. Pode confiar, os ganhos são infinitos!</p>
<p>Falando de cache em alta performance, eu focaria em duas opções: <a href=https://redis.io/>Redis</a> ou <a href=https://memcached.org/>Memcached</a>. Existem outras alternativas, mas eu iria com um deles, e entre os dois: Redis. Além de mais performático, ele possui diversas <a href=https://aws.amazon.com/elasticache/redis-vs-memcached/>outras vantagens</a>.</p>
<p><img src=images/5.png alt=7.png></p>
<blockquote>
<p><a href=http://oldblog.antirez.com/post/redis-memcached-benchmark.html>Fonte do benchmark</a></p>
</blockquote>
<p><strong>Bônus:</strong> utilizando <a href=https://github.com/phpredis/phpredis>essa extensão</a> do Redis para PHP, você tem ainda mais poder de otimização e assume o controle total do Redis de forma fácil e eficiente. É possível, por exemplo, armazenar suas sessões do PHP no Redis, ou seja, não precisa mais se preocupar com a performance do storage da aplicação, sua aplicação vai voar! :)</p>
<hr>
<h2 id=8-conexões-persistentes>8. Conexões persistentes<a href=#8-conexões-persistentes class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>Esse é um assunto que vi sendo abordado poucas vezes, quando o assunto é performance. Conexões persistentes são muito poderosas para trabalhar em alta volumetria.</p>
<p>Na verdade, ouvimos falar sobre <a href=https://en.wikipedia.org/wiki/HTTP_persistent_connection>conexões http persistentes</a>, mas elas não são as únicas que sua aplicação precisa lidar. Temos também ao banco de dados e ao Redis, por exemplo.</p>
<p>Vou utilizar a do banco de dados como exemplo. Lembra do php-fpm que gerencia seus processos? Certo! Vamos pensar que ele processou as 10 mil requisições que configuramos e que todas as requisições precisaram ir ao banco de dados duas vezes. Com uma conexão tradicional, apenas uma seria aberta para realizar as duas queries, show! Mas pensando em um ambiente macro, nessas 10 mil requisições teríamos que fazer isso 10 mil vezes!</p>
<p>O recurso computacional exigido nesse processo, tanto da aplicação, quanto do banco de dados é de se levar em consideração. Com isso, podemos utilizar as conexões persistentes e reaproveitar uma conexão já aberta para esse processo e com certeza ter um ganho expressivo em recursos e performance, claro.</p>
<p>E para utilizar é bem simples, basta passar o parâmetro de configuração <code>PDO::ATTR_PERSISTENT</code> ao driver de conexão como <code>true</code>. Para saber um pouco mais vale conferir a <a href=https://www.php.net/manual/en/pdo.connections.php>documentação oficial</a>.</p>
<p>Caso queira ler um pouco mais, vou deixar um <a href=https://www.valinv.com/dev/mysql-mysql-persistent-connections-in-php>link interessante aqui</a> sobre conexões persistentes ao banco de dados.</p>
<p>Ao utilizar o Redis com <a href=https://github.com/phpredis/phpredis#pconnect-popen>PhpRedis</a> (o mais recomendado), basta mudar a forma de conectar para <code>$redis->pconnect()</code> , simples assim!</p>
<hr>
<h2 id=9-funções-nativas>9. Funções nativas<a href=#9-funções-nativas class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>Bom, todos sabemos que <a href=https://www.php.net/manual/en/indexes.functions.php>elas existem</a>. Mas realmente usamos? Aqui tem um <a href=https://www.exakat.io/top-100-php-functions/>top 100</a> das funções nativas mais utilizadas em projetos open source. Não quero entrar no mérito se foram bem utilizadas ou não, mas é um ranking interessante para analisar quais são mais utilizadas e dar um primeiro passo.</p>
<p>Hoje em dia, eu quase nunca utilizo loops na mão. Isso porque consigo resolver quase tudo com funções nativas, que são mais performáticas. Elas também ajudam bastante quando pensamos em manutenção de código, pois facilitam o entendimento na hora de ler.</p>
<p>Um teste rápido, qual você consegue entender mais rápido?</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=color:#75715e>// Job
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>cube</span>($number) {
    <span style=color:#66d9ef>return</span> ($number <span style=color:#f92672>*</span> $number <span style=color:#f92672>*</span> $number);
}

<span style=color:#75715e>// Without native
</span><span style=color:#75715e></span>$cubes <span style=color:#f92672>=</span> [];
<span style=color:#66d9ef>foreach</span>($numbers <span style=color:#66d9ef>as</span> $number) {
    $cubes[] <span style=color:#f92672>=</span> <span style=color:#a6e22e>cube</span>($number);
}

<span style=color:#75715e>// With native
</span><span style=color:#75715e></span>$cubes <span style=color:#f92672>=</span> <span style=color:#a6e22e>array_map</span>(<span style=color:#e6db74>&#39;cube&#39;</span>, $numbers);
</code></pre></div><p>Fiz um <a href=https://gist.github.com/leocarmo/4a1320da1b61523c0c8d00ef2a3524e3>benchmark rápido</a> com esse código, e utilizando <code>array_map</code> consegui um resultado quase 15% mais performático, testando um array com 1.000.000 elementos 1.000 vezes.</p>
<p>Uma outra solução que gosto bastante é utilizar <a href=https://laravel.com/docs/7.x/collections>Laravel Collections</a>. O código fica mais limpo e legível, além de utilizar diversas funções nativas &ldquo;por baixo&rdquo;.</p>
<hr>
<h2 id=10-preloading>10. Preloading<a href=#10-preloading class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>O PHP 7.4 veio com uma novidade bem bacana, o preloading do <a href=https://leonardocarmo.medium.com/guia-alta-performance-com-php-suas-aplica%C3%A7%C3%B5es-backend-no-pr%C3%B3ximo-n%C3%ADvel-c0a3ca9aed10#9c93>OPcache</a>, que falamos ali em cima. Resolvi falar sobre isso separadamente para entrar um pouco mais no detalhe, e por serem coisas diferentes mas complementares.</p>
<p><strong>E qual a diferença, na prática, em usar esse preloading?</strong></p>
<p>Como já sabemos, a principal característica do OPcache é armazenar os arquivos já compilados (&ldquo;opcodes&rdquo;) em memória para serem reutilizados. Certo, já falamos sobre isso. Mas ele faz isso sem relacionar tudo que foi compilado e não consegue resolver dependências entre as classes quando chegar uma requisição, ou seja, já está tudo em memória, mas quando uma classe herda outra, essa relação precisa ser vinculada.</p>
<p>Sendo assim, a cada requisição, ele precisa vincular as dependências entre as classes em tempo de execução. Lembra do ponto em reaproveitar trabalho? Bom, se podemos reaproveitar, podemos ganhar performance!</p>
<p>Para implementar esse preloading, alguns frameworks já trazem alguma solução pronta, como por exemplo o <a href=https://symfony.com/blog/new-in-symfony-4-4-preloading-symfony-applications-in-php-7-4>Symfony</a>.</p>
<p>Mas nada que não possa ser feito em outro framework. Basicamente é apontar um arquivo de preload no seu <code>php.ini</code> dentro das configurações do OPcache.</p>
<pre><code>opcache.preload=/path/to/project/preload.php
</code></pre><p>E dentro deste arquivo, carregar todo o seu projeto.</p>
<pre><code>$files = require 'vendor/composer/autoload_classmap.php';

foreach (array_unique($files) as $file) {
    opcache_compile_file($file);
}
</code></pre><p>Bom, neste exemplo iríamos carregar o projeto todo. Para iniciar não é ruim, mas tendo em mente que é preciso melhorar.</p>
<p>Nosso projeto não utiliza TODOS os arquivos e TODAS classes que temos, então qual motivo de carregar tudo?</p>
<p>Aqui tem uma thread para se adicionar o preloading no composer de forma nativa, <a href=https://github.com/composer/composer/issues/7777#issuecomment-440268416>mas tem um comentário</a> bem bacana sobre os ganhos de fazer um preloading apenas das classes mais utilizadas no projeto.</p>
<p><img src=images/6.png alt=10.1.png></p>
<p>Com isso, da para ter uma ideia do custo/benefício de cada abordagem. Eu recomendo o preloading apenas das classes principais. Mas, você pode começar fazendo do projeto todo para ter um ganho inicial.</p>
<p>Até o momento, ainda não utilizei <a href=https://github.com/DarkGhostHunter/Preloader>esta lib</a>, mas achei bem interessante a ideia e pretendo utilizar. Quando fizer, coloco aqui os resultados.</p>
<p><a href=https://stitcher.io/blog/preloading-in-php-74>Aqui tem um artigo</a> bacana sobre esse assunto, onde você pode se aprofundar um pouco mais.</p>
<p><strong>Bônus:</strong> como falamos sobre o composer, não vou abrir uma sessão exclusiva pra isso, acho que podemos resumir rapidamente o que precisa ser feito para otimizá-lo. Na <a href=https://getcomposer.org/doc/articles/autoloader-optimization.md>documentação oficial</a> tem os detalhes, então para instalar seu projeto em produção utilize estas instruções:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>/usr/bin/composer install --no-dev -o -a
</code></pre></div><hr>
<h2 id=11-generators>11. Generators<a href=#11-generators class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>Essa também é uma ferramenta bem poderosa que temos, não apenas no PHP, mas em todo o ecossistema de desenvolvimento. Na <a href=https://www.php.net/manual/en/language.generators.overview.php>documentação oficial</a>, temos um detalhamento melhor sobre isso, mas podemos resumir em dois itens:</p>
<ul>
<li>É uma forma simples de escrever <a href=https://www.php.net/manual/en/language.oop5.iterations.php>iterators</a></li>
<li>É possível iterar dados sem precisar construir um array em memória</li>
</ul>
<p>Com isso em mente, e ainda analisando a documentação oficial, temos um exemplo de implementação de um <code>range()</code> que vou fazer uma alteração para ilustrar melhor a ideia:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=color:#75715e>// range nativo
</span><span style=color:#75715e></span><span style=color:#66d9ef>foreach</span> (<span style=color:#a6e22e>range</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1_000_000</span>) <span style=color:#66d9ef>as</span> $number) {
    <span style=color:#66d9ef>echo</span> $number <span style=color:#f92672>.</span> <span style=color:#a6e22e>PHP_EOL</span>;
}

<span style=color:#75715e>// range com generator
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>xrange</span>(<span style=color:#a6e22e>int</span> $start, <span style=color:#a6e22e>int</span> $end) {
    <span style=color:#66d9ef>for</span> ($i <span style=color:#f92672>=</span> $start; $i <span style=color:#f92672>&lt;=</span> $end; $i<span style=color:#f92672>++</span>) {
        <span style=color:#66d9ef>yield</span> $i;
    }
}

<span style=color:#66d9ef>foreach</span> (<span style=color:#a6e22e>xrange</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1_000_000</span>) <span style=color:#66d9ef>as</span> $number) {
    <span style=color:#66d9ef>echo</span> $number <span style=color:#f92672>.</span> <span style=color:#a6e22e>PHP_EOL</span>;
}
</code></pre></div><p>Se você tentar rodar esse código, pode ser que você receba um: <code>Fatal error: Allowed memory size</code> (dependendo da sua configuração no <code>php.ini</code>).</p>
<p>Na implementação nativa do <code>range</code>, por ele tentar alocar em memória 1M de integers, você pode explodir seu script por falta de memória. O que no <code>xrange</code> não ocorre, pois ele alocou apenas 1. Sim, isso mesmo, apenas 1.</p>
<blockquote>
<p><strong>Que diferença hein?!</strong></p>
</blockquote>
<p>Isso ocorre pois o retorno vai &ldquo;passo a passo&rdquo;, retornando um generator para que o <code>foreach</code> o execute um a um. É uma prática bem comum utilizar essa técnica ao ler arquivos bem grandes.</p>
<p>Bom, acho que ja é possível entender os ganhos até aqui de se utilizar essa técnica. Foi pensando nisso que o Laravel implementou as <a href=https://laravel.com/docs/master/collections#lazy-collections>LazyCollections</a>, por exemplo.</p>
<blockquote>
<p>Mas os generators vão além disso. E é aqui que tudo começa a ficar bem mais interessante! Os generators abrem as portas para se trabalhar com corrotinas utilizando PHP. Sim, muito maneiro! E isso já existe desde a versão 5.5.</p>
</blockquote>
<p>Aqui o assunto começa a ficar mais complexo, e tudo bem, não é fácil entender tudo isso logo de cara&mldr; É uma forma diferente de manipular e interagir com o estado de uma aplicação, então, antes de avançar, recomendo que você entenda melhor este e outros termos que vamos começar a utilizar daqui pra frente, e como tudo isso se relaciona.</p>
<p>Para isso, vou deixar um roteiro de artigos aqui para você:</p>
<ul>
<li><a href=https://www.treinaweb.com.br/blog/concorrencia-paralelismo-processos-threads-programacao-sincrona-e-assincrona/>Introdução teórica a estes termos</a></li>
<li><a href=https://thephp.website/br/edicao/voce-achou-que-sabia-sobre-generators/>Entendendo mais sobre generators</a></li>
<li><a href=https://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html>Corrotinas com generators</a></li>
</ul>
<hr>
<h2 id=12-código-assíncrono>12. Código assíncrono<a href=#12-código-assíncrono class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>Bom, a partir daqui, podemos assumir que você já entende a teoria sobre processos assíncronos. Então, nada melhor do que começar a colocar isso em prática!</p>
<p>Existem muitas formas de começar, mas quero usar uma abordagem pensando em como melhorar algum serviço que você já tenha funcionando em produção, sem precisar mudar framework ou uma grande quantidade de código.</p>
<blockquote>
<p>Antes de iniciar de fato no código assíncrono, queria apenas pontuar a diferença de se utilizar jobs assíncronos. Não quero entrar muito no detalhe, vou deixar a <a href=https://laravel.com/docs/master/queues>documentação do Laravel</a> sobre isso, tem bastante conteúdo lá. Também é algo extremamente recomendado ao se pensar em performance, então caso você não conheça, comece a utilizar!</p>
</blockquote>
<p>Para colocar a mão na massa, queria introduzir a utilização <a href=https://github.com/spatie/async>desta biblioteca</a>, já utilizei e gostei bastante. Ela resolve um problema clássico onde você precisa buscar dados em diferentes lugares mas eles não são dependentes, ou seja, é possível busca-los ao mesmo tempo e reduzir o tempo de resposta da aplicação.</p>
<p>A documentação é bem bacana, tem diversos exemplos e é bem simples de se utilizar. Com pouco código, já é possível conseguir bons resultados, e o melhor, sem precisar alterar todo seu sistema.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=color:#66d9ef>use</span> <span style=color:#a6e22e>Spatie\Async\Pool</span>;

$pool <span style=color:#f92672>=</span> <span style=color:#a6e22e>Pool</span><span style=color:#f92672>::</span><span style=color:#a6e22e>create</span>();

<span style=color:#66d9ef>foreach</span> ($things <span style=color:#66d9ef>as</span> $thing) {
    $pool<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>function</span> () <span style=color:#66d9ef>use</span> ($thing) {
        <span style=color:#75715e>// Do a thing
</span><span style=color:#75715e></span>    })<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>then</span>(<span style=color:#66d9ef>function</span> ($output) {
        <span style=color:#75715e>// Handle success
</span><span style=color:#75715e></span>    })<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>catch</span>(<span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>Throwable</span> $exception) {
        <span style=color:#75715e>// Handle exception
</span><span style=color:#75715e></span>    });
}

$pool<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>wait</span>();
</code></pre></div><p>Claro, isso é uma abordagem bem inicial. <a href=https://stitcher.io/blog/asynchronous-php>Aqui tem uma publicação</a> que fala um pouco dessa primeira abordagem e o problema que ela quer resolver. Criar sistemas é assim, saber utilizar a ferramenta correta para resolver um problema específico, e mesmo assim as possibilidades são amplas. Então saiba escolher o que utilizar e quando utilizar!</p>
<hr>
<h2 id=13-non-blocking-io-com-php>13. Non-blocking I/O com PHP<a href=#13-non-blocking-io-com-php class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>Pode falar, título maneiro né? E sim, muitos programadores realmente duvidam que isso existe no PHP, além de existir é muito poderoso!</p>
<p>As primeiras soluções encontradas ao se iniciar nesse assunto no PHP é o <a href=https://amphp.org/>Apm</a> e o <a href=https://reactphp.org/>ReactPHP</a>. Sim, vamos falar sobre eles aqui, mas calma, tem mais!</p>
<p>Basicamente essas implementações seguem a <a href=https://en.wikipedia.org/wiki/Reactor_pattern>Reactor Design Pattern</a>, implementando uma arquitetura orientada a eventos, realizando operações I/O de forma não bloqueante, utilizando um <a href=https://reactphp.org/event-loop/>event loop</a> como core.</p>
<p>Com esse event loop, um mar de possibilidades é aberto, podemos implementar servidor http, por exemplo, onde a utilização do Nginx se torna opcional, e não mais obrigatória para rodar seu código.</p>
<p>Para iniciar um Hello World no ReactPHP é bem simples, na <a href=https://reactphp.org/>página inicial da documentação</a> já tem um exemplo bacana. Caso você queira começar a explorar mais sobre ele, a documentação tem bastante conteúdo.</p>
<p><img src=images/7.jpeg alt="Hello World com ReactPHP"></p>
<p>Mas estamos aqui para falar de um framework que entrega o maior nível de performance para aplicações PHP: o <a href=https://www.swoole.co.uk/>Swoole</a>. Sou um pouco suspeito para falar sobre este assunto, pois quando conheci foi amor a primeira vista. Ele é realmente incrível. Os citados acima também são interessantes, acho que vale a pena conhecer, mas se for para escolher, com certeza vou de Swoole!</p>
<p><img src=images/8.png alt=13.2.png></p>
<blockquote>
<p>Funcionamento do PHP-FPM + Nginx vs. Swoole</p>
</blockquote>
<p>Uma das coisas que achei sensacional foi o suporte nativo de múltiplos cores de CPU e <a href=https://www.swoole.co.uk/docs/modules/swoole-multiprocessing>multiprocessamento</a> (<a href=https://pt.wikipedia.org/wiki/Multiprocessamento>?</a>), dando mais poder para o Swoole.</p>
<p>Também é possível <a href=https://www.swoole.co.uk/docs/modules/swoole-process-pool>gerenciar um conjunto de processos</a> de forma muito fácil. Vamos pensar em um caso de uso real. Você vai realizar diversas operações em um Redis, para isso você precisa de uma conexão. Para extrair o máximo de performance, é recomendado realizar um pool de conexões e reutiliza-las. Como fazer isso então?</p>
<p>Primeiro, precisamos iniciar estas conexões. Faremos isso quando um worker do Swoole for iniciado <code>(WorkerStart)</code>, assim não prejudicamos o tempo das requisições que vão chegar, pois faremos isso antes do worker estar pronto. Iremos utilizar o <a href=https://www.swoole.co.uk/docs/modules/swoole-coroutine-channel>Swoole Coroutine Channel</a> para compartilhar as conexões abertas entre as requisições.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=color:#f92672>&lt;?</span><span style=color:#a6e22e>php</span>

<span style=color:#66d9ef>use</span> <span style=color:#a6e22e>Swoole\Http\Server</span>;
<span style=color:#66d9ef>use</span> <span style=color:#a6e22e>Swoole\Coroutine\Channel</span>;
<span style=color:#66d9ef>use</span> <span style=color:#a6e22e>Swoole\Coroutine\Redis</span>;

$server <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Server</span>(<span style=color:#e6db74>&#39;0.0.0.0&#39;</span>, <span style=color:#ae81ff>8000</span>);

$chan <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Channel</span>(<span style=color:#ae81ff>100</span>);

$server<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>on</span>(
    <span style=color:#e6db74>&#39;WorkerStart&#39;</span>,
    <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>Server</span> $server) <span style=color:#66d9ef>use</span> ($chan) {
        <span style=color:#66d9ef>for</span> ($i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; $i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>100</span>; $i<span style=color:#f92672>++</span>) {
            $redis <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Redis</span>();
            $redis<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>connect</span>(<span style=color:#e6db74>&#39;127.0.0.1&#39;</span>, <span style=color:#ae81ff>6379</span>);
            $chan<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>push</span>($redis);
        }
    }
);

$server<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>on</span>(
    <span style=color:#e6db74>&#39;request&#39;</span>,
    <span style=color:#66d9ef>function</span> ($request, $response) <span style=color:#66d9ef>use</span> ($chan) {
        <span style=color:#e6db74>/** @var Redis $redis */</span>
        $redis <span style=color:#f92672>=</span> $chan<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>pop</span>();

        $redis<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>set</span>(<span style=color:#e6db74>&#39;swoole&#39;</span>, <span style=color:#a6e22e>rand</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>100</span>));
        $result <span style=color:#f92672>=</span> $redis<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#39;swoole&#39;</span>);

        $response<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>end</span>(<span style=color:#e6db74>&#34;&lt;h1&gt;Hello World. #</span><span style=color:#e6db74>{</span>$result<span style=color:#e6db74>}</span><span style=color:#e6db74>&lt;/h1&gt;&#34;</span>);

        <span style=color:#75715e>// return connection to the channel
</span><span style=color:#75715e></span>        $chan<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>push</span>($redis);
    }
);

$server<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>start</span>();
</code></pre></div><p>Neste exemplo acima, podemos ainda implementar um <a href=https://www.swoole.co.uk/docs/modules/swoole-timer>Timer</a>, que de tempos em tempos valida se todas as conexões estão ativas, caso não esteja, ele renova automaticamente sem afetar uma requisição. Dando mais poder para nossa aplicação.</p>
<p>Tudo isso se baseando nas <a href=https://www.swoole.co.uk/docs/modules/swoole-coroutine>Swoole Coroutines</a>, onde ao escrever um código no &ldquo;estilo síncrono&rdquo;, temos todo o poder do async I/O non-blocking proporcionado pelo Swoole, sem precisar ficar escrevendo callbacks e awaits pelo código.</p>
<p>O Swoole muda bastante o comportamento do PHP, por exemplo ao reutilizar tudo que foi alocado em memória entre as requisições, antes de utilizar em produção, leia <strong>MUITO</strong> sobre essa e outras mudanças de comportamento para não enfrentar problemas.</p>
<p>É possível rodar aplicações <a href=https://github.com/swooletw/laravel-swoole>Laravel</a> e <a href=https://www.swoole.co.uk/article/symfony-swoole>Symfony</a> em cima do Swoole de forma fácil. É bom para começar a entender como ele funciona, mas para atingir a máxima performance, não é o recomendado. Para isso, temos frameworks próprios, por exemplo o <a href=https://www.easyswoole.com/En/Preface/introduction.html>easySwoole</a> e o <a href=https://hyperf.wiki/2.1/#/en/>Hyperf</a>.</p>
<p>Na documentação oficial, existe uma <a href=https://www.swoole.co.uk/articles>seção de artigos</a> explicando algumas implementações e uma <a href=https://www.swoole.co.uk/docs/common-questions-index>FAQ</a>, caso queira se aprofundar mais tem coisa bem bacana por lá.</p>
<hr>
<p>Bom, por enquanto vamos ficando por aqui. Com todas essas dicas, acredito que suas aplicações vão realmente atingir resultados incríveis usando PHP.</p>
<p>Depois me conta se essas dicas fizeram efeito nos seus projetos e o quanto isso te ajudou! (:</p>
</div></div>
<div class=pagination>
<div class=pagination__title>
<span class=pagination__title-h>Read other posts</span>
<hr>
</div>
<div class=pagination__buttons>
<span class="button previous">
<a href=/graceful-shutdown-com-php-evitando-data-corruption/>
<span class=button__icon>←</span>
<span class=button__text>Graceful Shutdown com PHP - Evitando data corruption</span>
</a>
</span>
</div>
</div>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//leocarmodev.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</div>
</div>
<footer class=footer>
<div class=footer__inner>
<div class="copyright copyright--user">
<span>leocarmo.dev</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span>
</div>
</div>
</footer>
<script src=/assets/main.js></script>
<script src=/assets/prism.js></script>
<script>window.onload=function(){let a=document.getElementsByTagName('a'),b=window.location.hostname;for(let c=0;c<a.length;c++){if(a[c].href.includes(b))continue;a[c].setAttribute('target','_blank')}}</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WG95JRMMET"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-WG95JRMMET')</script>
</div>
</body>
</html>